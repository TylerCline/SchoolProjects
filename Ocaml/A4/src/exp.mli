open Batteries
open BatFormat

(** The [Exp] module defines the source language of the [Grumpy] compiler. *)

open Lexing

open AST

(** [raw_exp] (and the related [exp]) is the main datatype. *)
type 'a raw_exp =
  | EInt of int32                       (** 32-bit integers *)
  | EFloat of float                     (** Double-precision floats *)
  | EId of id                           (** Program identifiers [x, y, z, ...] *)
  | ESeq of ('a exp) list               (** [e1; e2; ...; eN] *)
  | ECall of id * ('a exp) list         (** [f(e1, e2, ..., eM)] *)
  | ERef of 'a exp                      (** Allocate a reference cell *)
  | EUnop of unop * 'a exp              (** Apply a unary operation, e.g. [-e] *)
  | EBinop of binop * 'a exp * 'a exp   (** Apply a binary operation e.g., [e1+e2] *)
  | EIf of 'a exp * 'a exp * 'a exp     (** Conditional [if e1 then e2 else e3] *)
  | ELet of id * 'a exp * 'a exp        (** [let x = e1 in e2] *)
  | EScope of 'a exp			(** \{ e \} *)   
  | EUnit                               (** The unit value () *)
  | ETrue                               (** true *)
  | EFalse                              (** false *)
  | EWhile of 'a exp * 'a exp           (** while e1 \{ e2 \} *)

(** [exp] and [raw_exp] are defined mutually recursively. An [exp] is 
    just a [raw_exp] together with: 
    - A source-file position [start_of], the point at which this expression 
      began in the source file being compiled
    - An [end_of] position, giving the spot in the source file where this 
      expression ended, and 
    - Some [extra] data, of OCaml type ['a]. Before typechecking, in the 
      expressions generated by the parser, [extra] will be instantiated to 
      the OCaml type [unit], type type that encodes no information. 
      After typechecking, ['a] will equal [ty], encoding the type of each 
      sub-expression in the program's AST *)      
and 'a exp = 
  { start_of : Lexing.position;         (** The source-file startpos of this [exp] *)  
    end_of : Lexing.position;           (** The source-file endpos of this [exp] *)  
    exp_of : 'a raw_exp;                (** The [exp] itself *)
    ety_of : 'a }                       (** The "extra" data, typically a type *)
(** Note that, in the constructors of [raw_exp] above that take expression
    arguments, we use [exp] instead of [raw_exp]. This ensures that we record
    position information for all sub-expressions in the AST. *)

(** Check whether two types are equal *)
val ty_eq : ty -> ty -> bool
  
(** A "smart constructor" for [ESeq], implementing the following equations: 
- [exp_seq (ESeq l1) (ESeq l2) = ESeq (l1 ^ l2)]
- [exp_seq e1 (ESeq l2)        = ESeq (e1 :: l2)]
- [exp_seq (ESeq l1) e2        = ESeq (l1 ^ [e2])]
- [exp_seq e1 e2               = ESeq (e1 :: e2 :: nil)] *)
val exp_seq : 'a exp -> 'a exp -> 'a raw_exp

(** Pretty-print an expression *)
val pp_exp : formatter -> 'a exp -> unit

(** Pretty-print a type-annotated expression *)
val pp_texp : formatter -> ty exp -> unit
				      
(** Pretty-print a source-code position *)
val pp_pos : formatter -> 'a exp -> unit
